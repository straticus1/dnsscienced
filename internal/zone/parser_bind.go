package zone

import (
	"fmt"
	"os"
	"strings"

	"github.com/miekg/dns"
)

// ParseBIND parses a BIND-style zone file
// This provides compatibility for migrating from BIND/NSD
func ParseBIND(filename string, origin string, cfg Config) (*Zone, error) {
	// Read file
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("read file: %w", err)
	}

	// Ensure origin is FQDN
	if origin != "" && origin[len(origin)-1] != '.' {
		origin += "."
	}

	// Create zone
	zone := New(origin)

	// Parse using miekg/dns library
	zoneParser := dns.NewZoneParser(strings.NewReader(string(data)), origin, filename)

	// Set default TTL if specified
	if cfg.DefaultTTL > 0 {
		zoneParser.SetDefaultTTL(cfg.DefaultTTL)
	}

	// Allow $INCLUDE directives if enabled
	if cfg.AllowIncludes {
		zoneParser.SetIncludeAllowed(true)
	}

	// Parse all records
	for rr, ok := zoneParser.Next(); ok; rr, ok = zoneParser.Next() {
		if err := zone.AddRecord(rr); err != nil {
			if cfg.Strict {
				return nil, fmt.Errorf("add record %s: %w", rr.String(), err)
			}
			// In non-strict mode, skip invalid records
			continue
		}
	}

	// Check for parse errors
	if err := zoneParser.Err(); err != nil {
		return nil, fmt.Errorf("parse error: %w", err)
	}

	// Validate zone
	if cfg.Strict {
		if err := zone.Validate(); err != nil {
			return nil, fmt.Errorf("validation failed: %w", err)
		}
	}

	return zone, nil
}

// ExportBIND exports a zone to BIND format
func (z *Zone) ExportBIND() (string, error) {
	var sb strings.Builder

	// Write header comment
	sb.WriteString(fmt.Sprintf("; Zone file for %s\n", z.Name))
	sb.WriteString("; Generated by DNSScienced\n\n")

	// Write $ORIGIN
	sb.WriteString(fmt.Sprintf("$ORIGIN %s\n", z.Origin))

	// Write $TTL
	if z.SOA != nil {
		sb.WriteString(fmt.Sprintf("$TTL %d\n\n", z.SOA.Hdr.Ttl))
	} else {
		sb.WriteString("$TTL 3600\n\n")
	}

	// Write SOA first
	if z.SOA != nil {
		sb.WriteString(z.SOA.String())
		sb.WriteString("\n")
	}

	// Write NS records next (convention)
	ns := z.GetNameservers()
	if len(ns) > 0 {
		sb.WriteString("\n; Nameservers\n")
		for _, n := range ns {
			sb.WriteString(n.String())
			sb.WriteString("\n")
		}
	}

	// Write all other records grouped by owner
	writtenOwners := make(map[string]bool)
	if z.SOA != nil {
		writtenOwners[z.SOA.Header().Name] = true
	}

	// Sort owners for consistent output
	owners := make([]string, 0, len(z.Records))
	for owner := range z.Records {
		if !writtenOwners[owner] {
			owners = append(owners, owner)
		}
	}

	// Write records by owner
	for _, owner := range owners {
		typeMap := z.Records[owner]

		// Skip if only NS records (already written)
		if len(typeMap) == 1 {
			if _, isNS := typeMap[dns.TypeNS]; isNS {
				continue
			}
		}

		sb.WriteString(fmt.Sprintf("\n; %s\n", owner))

		// Write records in conventional order
		conventionalOrder := []uint16{
			dns.TypeA,
			dns.TypeAAAA,
			dns.TypeCNAME,
			dns.TypeMX,
			dns.TypeTXT,
			dns.TypeSRV,
			dns.TypeCAA,
		}

		// Write in conventional order first
		for _, rrtype := range conventionalOrder {
			if records, ok := typeMap[rrtype]; ok {
				for _, rr := range records {
					sb.WriteString(rr.String())
					sb.WriteString("\n")
				}
			}
		}

		// Write remaining types
		for rrtype, records := range typeMap {
			// Skip if already written
			skip := false
			for _, t := range conventionalOrder {
				if rrtype == t {
					skip = true
					break
				}
			}
			if rrtype == dns.TypeNS {
				skip = true
			}
			if skip {
				continue
			}

			for _, rr := range records {
				sb.WriteString(rr.String())
				sb.WriteString("\n")
			}
		}
	}

	return sb.String(), nil
}

// ConvertBINDToDNSZone converts a BIND zone file to .dnszone YAML format
// This is a helper for migration
func ConvertBINDToDNSZone(bindFile, origin string, cfg Config) (string, error) {
	// Parse BIND file
	zone, err := ParseBIND(bindFile, origin, cfg)
	if err != nil {
		return "", fmt.Errorf("parse BIND file: %w", err)
	}

	// Convert to YAML structure
	var sb strings.Builder

	sb.WriteString("# Converted from BIND zone file\n")
	sb.WriteString(fmt.Sprintf("# Original: %s\n\n", bindFile))

	// Zone section
	sb.WriteString("zone:\n")
	sb.WriteString(fmt.Sprintf("  name: %s\n", strings.TrimSuffix(zone.Name, ".")))
	if zone.SOA != nil {
		sb.WriteString(fmt.Sprintf("  ttl: %ds\n", zone.SOA.Hdr.Ttl))
	}
	sb.WriteString("  class: IN\n\n")

	// SOA section
	if zone.SOA != nil {
		sb.WriteString("soa:\n")
		sb.WriteString(fmt.Sprintf("  primary_ns: %s\n", strings.TrimSuffix(zone.SOA.Ns, ".")))

		// Convert mbox back to email format
		mbox := strings.TrimSuffix(zone.SOA.Mbox, ".")
		email := strings.Replace(mbox, ".", "@", 1)
		sb.WriteString(fmt.Sprintf("  contact: %s\n", email))

		sb.WriteString(fmt.Sprintf("  serial: %d\n", zone.SOA.Serial))
		sb.WriteString(fmt.Sprintf("  refresh: %ds\n", zone.SOA.Refresh))
		sb.WriteString(fmt.Sprintf("  retry: %ds\n", zone.SOA.Retry))
		sb.WriteString(fmt.Sprintf("  expire: %ds\n", zone.SOA.Expire))
		sb.WriteString(fmt.Sprintf("  negative_ttl: %ds\n\n", zone.SOA.Minttl))
	}

	// Records section
	sb.WriteString("records:\n")

	// Convert each owner's records
	for owner, typeMap := range zone.Records {
		// Make owner relative to zone
		relName := makeRelative(owner, zone.Origin)

		sb.WriteString(fmt.Sprintf("  %s:\n", quoteIfNeeded(relName)))

		// Convert each record type
		for rrtype, records := range typeMap {
			// Skip SOA (already written)
			if rrtype == dns.TypeSOA {
				continue
			}

			typeName := dns.TypeToString[rrtype]

			// Handle different record types
			switch rrtype {
			case dns.TypeA:
				ips := []string{}
				for _, rr := range records {
					a := rr.(*dns.A)
					ips = append(ips, a.A.String())
				}
				if len(ips) == 1 {
					sb.WriteString(fmt.Sprintf("    %s: %s\n", typeName, ips[0]))
				} else {
					sb.WriteString(fmt.Sprintf("    %s:\n", typeName))
					for _, ip := range ips {
						sb.WriteString(fmt.Sprintf("      - %s\n", ip))
					}
				}

			case dns.TypeAAAA:
				ips := []string{}
				for _, rr := range records {
					aaaa := rr.(*dns.AAAA)
					ips = append(ips, aaaa.AAAA.String())
				}
				if len(ips) == 1 {
					sb.WriteString(fmt.Sprintf("    %s: %s\n", typeName, ips[0]))
				} else {
					sb.WriteString(fmt.Sprintf("    %s:\n", typeName))
					for _, ip := range ips {
						sb.WriteString(fmt.Sprintf("      - %s\n", ip))
					}
				}

			case dns.TypeCNAME:
				cname := records[0].(*dns.CNAME)
				target := makeRelative(cname.Target, zone.Origin)
				sb.WriteString(fmt.Sprintf("    %s: %s\n", typeName, target))

			case dns.TypeMX:
				sb.WriteString(fmt.Sprintf("    %s:\n", typeName))
				for _, rr := range records {
					mx := rr.(*dns.MX)
					target := makeRelative(mx.Mx, zone.Origin)
					sb.WriteString(fmt.Sprintf("      - priority: %d\n", mx.Preference))
					sb.WriteString(fmt.Sprintf("        target: %s\n", target))
				}

			case dns.TypeNS:
				nameservers := []string{}
				for _, rr := range records {
					ns := rr.(*dns.NS)
					nameservers = append(nameservers, makeRelative(ns.Ns, zone.Origin))
				}
				if len(nameservers) == 1 {
					sb.WriteString(fmt.Sprintf("    %s: %s\n", typeName, nameservers[0]))
				} else {
					sb.WriteString(fmt.Sprintf("    %s:\n", typeName))
					for _, ns := range nameservers {
						sb.WriteString(fmt.Sprintf("      - %s\n", ns))
					}
				}

			case dns.TypeTXT:
				txtRecords := []string{}
				for _, rr := range records {
					txt := rr.(*dns.TXT)
					txtRecords = append(txtRecords, strings.Join(txt.Txt, ""))
				}
				if len(txtRecords) == 1 {
					sb.WriteString(fmt.Sprintf("    %s: %q\n", typeName, txtRecords[0]))
				} else {
					sb.WriteString(fmt.Sprintf("    %s:\n", typeName))
					for _, txt := range txtRecords {
						sb.WriteString(fmt.Sprintf("      - %q\n", txt))
					}
				}

			case dns.TypeSRV:
				sb.WriteString(fmt.Sprintf("    %s:\n", typeName))
				for _, rr := range records {
					srv := rr.(*dns.SRV)
					target := makeRelative(srv.Target, zone.Origin)
					sb.WriteString(fmt.Sprintf("      - priority: %d\n", srv.Priority))
					sb.WriteString(fmt.Sprintf("        weight: %d\n", srv.Weight))
					sb.WriteString(fmt.Sprintf("        port: %d\n", srv.Port))
					sb.WriteString(fmt.Sprintf("        target: %s\n", target))
				}
			}
		}
	}

	return sb.String(), nil
}

// Helper: make name relative to origin
func makeRelative(name, origin string) string {
	if name == origin {
		return "@"
	}
	if strings.HasSuffix(name, "."+origin) {
		return strings.TrimSuffix(name, "."+origin)
	}
	return strings.TrimSuffix(name, ".")
}

// Helper: quote name if it contains special characters
func quoteIfNeeded(name string) string {
	// Quote if contains special YAML characters
	if strings.ContainsAny(name, "@*:") {
		return fmt.Sprintf("%q", name)
	}
	return name
}
