// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.4
// source: dnssec.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// DNSSEC Algorithm enumeration
type DNSSECAlgorithm int32

const (
	DNSSECAlgorithm_DNSSEC_ALGORITHM_UNSPECIFIED     DNSSECAlgorithm = 0
	DNSSECAlgorithm_DNSSEC_ALGORITHM_RSASHA256       DNSSECAlgorithm = 8
	DNSSECAlgorithm_DNSSEC_ALGORITHM_RSASHA512       DNSSECAlgorithm = 10
	DNSSECAlgorithm_DNSSEC_ALGORITHM_ECDSAP256SHA256 DNSSECAlgorithm = 13
	DNSSECAlgorithm_DNSSEC_ALGORITHM_ECDSAP384SHA384 DNSSECAlgorithm = 14
	DNSSECAlgorithm_DNSSEC_ALGORITHM_ED25519         DNSSECAlgorithm = 15
	DNSSECAlgorithm_DNSSEC_ALGORITHM_ED448           DNSSECAlgorithm = 16
)

// Enum value maps for DNSSECAlgorithm.
var (
	DNSSECAlgorithm_name = map[int32]string{
		0:  "DNSSEC_ALGORITHM_UNSPECIFIED",
		8:  "DNSSEC_ALGORITHM_RSASHA256",
		10: "DNSSEC_ALGORITHM_RSASHA512",
		13: "DNSSEC_ALGORITHM_ECDSAP256SHA256",
		14: "DNSSEC_ALGORITHM_ECDSAP384SHA384",
		15: "DNSSEC_ALGORITHM_ED25519",
		16: "DNSSEC_ALGORITHM_ED448",
	}
	DNSSECAlgorithm_value = map[string]int32{
		"DNSSEC_ALGORITHM_UNSPECIFIED":     0,
		"DNSSEC_ALGORITHM_RSASHA256":       8,
		"DNSSEC_ALGORITHM_RSASHA512":       10,
		"DNSSEC_ALGORITHM_ECDSAP256SHA256": 13,
		"DNSSEC_ALGORITHM_ECDSAP384SHA384": 14,
		"DNSSEC_ALGORITHM_ED25519":         15,
		"DNSSEC_ALGORITHM_ED448":           16,
	}
)

func (x DNSSECAlgorithm) Enum() *DNSSECAlgorithm {
	p := new(DNSSECAlgorithm)
	*p = x
	return p
}

func (x DNSSECAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DNSSECAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_dnssec_proto_enumTypes[0].Descriptor()
}

func (DNSSECAlgorithm) Type() protoreflect.EnumType {
	return &file_dnssec_proto_enumTypes[0]
}

func (x DNSSECAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DNSSECAlgorithm.Descriptor instead.
func (DNSSECAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{0}
}

// Key type enumeration
type KeyType int32

const (
	KeyType_KEY_TYPE_UNSPECIFIED KeyType = 0
	KeyType_KEY_TYPE_KSK         KeyType = 1 // Key Signing Key
	KeyType_KEY_TYPE_ZSK         KeyType = 2 // Zone Signing Key
)

// Enum value maps for KeyType.
var (
	KeyType_name = map[int32]string{
		0: "KEY_TYPE_UNSPECIFIED",
		1: "KEY_TYPE_KSK",
		2: "KEY_TYPE_ZSK",
	}
	KeyType_value = map[string]int32{
		"KEY_TYPE_UNSPECIFIED": 0,
		"KEY_TYPE_KSK":         1,
		"KEY_TYPE_ZSK":         2,
	}
)

func (x KeyType) Enum() *KeyType {
	p := new(KeyType)
	*p = x
	return p
}

func (x KeyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyType) Descriptor() protoreflect.EnumDescriptor {
	return file_dnssec_proto_enumTypes[1].Descriptor()
}

func (KeyType) Type() protoreflect.EnumType {
	return &file_dnssec_proto_enumTypes[1]
}

func (x KeyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyType.Descriptor instead.
func (KeyType) EnumDescriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{1}
}

// Key status
type KeyStatus int32

const (
	KeyStatus_KEY_STATUS_UNSPECIFIED KeyStatus = 0
	KeyStatus_KEY_STATUS_ACTIVE      KeyStatus = 1
	KeyStatus_KEY_STATUS_PUBLISHED   KeyStatus = 2
	KeyStatus_KEY_STATUS_RETIRED     KeyStatus = 3
	KeyStatus_KEY_STATUS_REVOKED     KeyStatus = 4
	KeyStatus_KEY_STATUS_DELETED     KeyStatus = 5
)

// Enum value maps for KeyStatus.
var (
	KeyStatus_name = map[int32]string{
		0: "KEY_STATUS_UNSPECIFIED",
		1: "KEY_STATUS_ACTIVE",
		2: "KEY_STATUS_PUBLISHED",
		3: "KEY_STATUS_RETIRED",
		4: "KEY_STATUS_REVOKED",
		5: "KEY_STATUS_DELETED",
	}
	KeyStatus_value = map[string]int32{
		"KEY_STATUS_UNSPECIFIED": 0,
		"KEY_STATUS_ACTIVE":      1,
		"KEY_STATUS_PUBLISHED":   2,
		"KEY_STATUS_RETIRED":     3,
		"KEY_STATUS_REVOKED":     4,
		"KEY_STATUS_DELETED":     5,
	}
)

func (x KeyStatus) Enum() *KeyStatus {
	p := new(KeyStatus)
	*p = x
	return p
}

func (x KeyStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_dnssec_proto_enumTypes[2].Descriptor()
}

func (KeyStatus) Type() protoreflect.EnumType {
	return &file_dnssec_proto_enumTypes[2]
}

func (x KeyStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyStatus.Descriptor instead.
func (KeyStatus) EnumDescriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{2}
}

// Tri-state include mode for public key material
// OFF: never include; MAY: include if available and small enough; ON: include if available
type IncludeKeyMode int32

const (
	IncludeKeyMode_INCLUDE_KEY_MODE_UNSPECIFIED IncludeKeyMode = 0
	IncludeKeyMode_INCLUDE_KEY_MODE_OFF         IncludeKeyMode = 1
	IncludeKeyMode_INCLUDE_KEY_MODE_MAY         IncludeKeyMode = 2
	IncludeKeyMode_INCLUDE_KEY_MODE_ON          IncludeKeyMode = 3
)

// Enum value maps for IncludeKeyMode.
var (
	IncludeKeyMode_name = map[int32]string{
		0: "INCLUDE_KEY_MODE_UNSPECIFIED",
		1: "INCLUDE_KEY_MODE_OFF",
		2: "INCLUDE_KEY_MODE_MAY",
		3: "INCLUDE_KEY_MODE_ON",
	}
	IncludeKeyMode_value = map[string]int32{
		"INCLUDE_KEY_MODE_UNSPECIFIED": 0,
		"INCLUDE_KEY_MODE_OFF":         1,
		"INCLUDE_KEY_MODE_MAY":         2,
		"INCLUDE_KEY_MODE_ON":          3,
	}
)

func (x IncludeKeyMode) Enum() *IncludeKeyMode {
	p := new(IncludeKeyMode)
	*p = x
	return p
}

func (x IncludeKeyMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IncludeKeyMode) Descriptor() protoreflect.EnumDescriptor {
	return file_dnssec_proto_enumTypes[3].Descriptor()
}

func (IncludeKeyMode) Type() protoreflect.EnumType {
	return &file_dnssec_proto_enumTypes[3]
}

func (x IncludeKeyMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IncludeKeyMode.Descriptor instead.
func (IncludeKeyMode) EnumDescriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{3}
}

type DNSSECEvent_EventType int32

const (
	DNSSECEvent_EVENT_TYPE_UNSPECIFIED        DNSSECEvent_EventType = 0
	DNSSECEvent_EVENT_TYPE_KEY_CREATED        DNSSECEvent_EventType = 1
	DNSSECEvent_EVENT_TYPE_KEY_ACTIVATED      DNSSECEvent_EventType = 2
	DNSSECEvent_EVENT_TYPE_KEY_INACTIVATED    DNSSECEvent_EventType = 3
	DNSSECEvent_EVENT_TYPE_KEY_DELETED        DNSSECEvent_EventType = 4
	DNSSECEvent_EVENT_TYPE_KEY_EXPIRING       DNSSECEvent_EventType = 5
	DNSSECEvent_EVENT_TYPE_ROLLOVER_STARTED   DNSSECEvent_EventType = 6
	DNSSECEvent_EVENT_TYPE_ROLLOVER_COMPLETED DNSSECEvent_EventType = 7
	DNSSECEvent_EVENT_TYPE_ZONE_SIGNED        DNSSECEvent_EventType = 8
	DNSSECEvent_EVENT_TYPE_VALIDATION_FAILED  DNSSECEvent_EventType = 9
)

// Enum value maps for DNSSECEvent_EventType.
var (
	DNSSECEvent_EventType_name = map[int32]string{
		0: "EVENT_TYPE_UNSPECIFIED",
		1: "EVENT_TYPE_KEY_CREATED",
		2: "EVENT_TYPE_KEY_ACTIVATED",
		3: "EVENT_TYPE_KEY_INACTIVATED",
		4: "EVENT_TYPE_KEY_DELETED",
		5: "EVENT_TYPE_KEY_EXPIRING",
		6: "EVENT_TYPE_ROLLOVER_STARTED",
		7: "EVENT_TYPE_ROLLOVER_COMPLETED",
		8: "EVENT_TYPE_ZONE_SIGNED",
		9: "EVENT_TYPE_VALIDATION_FAILED",
	}
	DNSSECEvent_EventType_value = map[string]int32{
		"EVENT_TYPE_UNSPECIFIED":        0,
		"EVENT_TYPE_KEY_CREATED":        1,
		"EVENT_TYPE_KEY_ACTIVATED":      2,
		"EVENT_TYPE_KEY_INACTIVATED":    3,
		"EVENT_TYPE_KEY_DELETED":        4,
		"EVENT_TYPE_KEY_EXPIRING":       5,
		"EVENT_TYPE_ROLLOVER_STARTED":   6,
		"EVENT_TYPE_ROLLOVER_COMPLETED": 7,
		"EVENT_TYPE_ZONE_SIGNED":        8,
		"EVENT_TYPE_VALIDATION_FAILED":  9,
	}
)

func (x DNSSECEvent_EventType) Enum() *DNSSECEvent_EventType {
	p := new(DNSSECEvent_EventType)
	*p = x
	return p
}

func (x DNSSECEvent_EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DNSSECEvent_EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_dnssec_proto_enumTypes[4].Descriptor()
}

func (DNSSECEvent_EventType) Type() protoreflect.EnumType {
	return &file_dnssec_proto_enumTypes[4]
}

func (x DNSSECEvent_EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DNSSECEvent_EventType.Descriptor instead.
func (DNSSECEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{21, 0}
}

// DNSSECKey represents a DNSSEC key
type DNSSECKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // Key tag or unique identifier
	KeyTag        uint32                 `protobuf:"varint,2,opt,name=key_tag,json=keyTag,proto3" json:"key_tag,omitempty"`
	Type          KeyType                `protobuf:"varint,3,opt,name=type,proto3,enum=dnsscience.v1.KeyType" json:"type,omitempty"`
	Algorithm     DNSSECAlgorithm        `protobuf:"varint,4,opt,name=algorithm,proto3,enum=dnsscience.v1.DNSSECAlgorithm" json:"algorithm,omitempty"`
	Status        KeyStatus              `protobuf:"varint,5,opt,name=status,proto3,enum=dnsscience.v1.KeyStatus" json:"status,omitempty"`
	Created       *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	Activated     *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=activated,proto3" json:"activated,omitempty"`
	Inactivated   *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=inactivated,proto3" json:"inactivated,omitempty"`
	Deleted       *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=deleted,proto3" json:"deleted,omitempty"`
	Expires       *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=expires,proto3" json:"expires,omitempty"`
	PublicKey     string                 `protobuf:"bytes,11,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"` // Base64 encoded
	HasPrivateKey bool                   `protobuf:"varint,12,opt,name=has_private_key,json=hasPrivateKey,proto3" json:"has_private_key,omitempty"`
	// DS records
	DsRecords []*DSRecord `protobuf:"bytes,13,rep,name=ds_records,json=dsRecords,proto3" json:"ds_records,omitempty"`
	// Key generation parameters
	KeySize       int32 `protobuf:"varint,14,opt,name=key_size,json=keySize,proto3" json:"key_size,omitempty"` // For RSA keys
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSSECKey) Reset() {
	*x = DNSSECKey{}
	mi := &file_dnssec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSSECKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSSECKey) ProtoMessage() {}

func (x *DNSSECKey) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSSECKey.ProtoReflect.Descriptor instead.
func (*DNSSECKey) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{0}
}

func (x *DNSSECKey) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DNSSECKey) GetKeyTag() uint32 {
	if x != nil {
		return x.KeyTag
	}
	return 0
}

func (x *DNSSECKey) GetType() KeyType {
	if x != nil {
		return x.Type
	}
	return KeyType_KEY_TYPE_UNSPECIFIED
}

func (x *DNSSECKey) GetAlgorithm() DNSSECAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return DNSSECAlgorithm_DNSSEC_ALGORITHM_UNSPECIFIED
}

func (x *DNSSECKey) GetStatus() KeyStatus {
	if x != nil {
		return x.Status
	}
	return KeyStatus_KEY_STATUS_UNSPECIFIED
}

func (x *DNSSECKey) GetCreated() *timestamppb.Timestamp {
	if x != nil {
		return x.Created
	}
	return nil
}

func (x *DNSSECKey) GetActivated() *timestamppb.Timestamp {
	if x != nil {
		return x.Activated
	}
	return nil
}

func (x *DNSSECKey) GetInactivated() *timestamppb.Timestamp {
	if x != nil {
		return x.Inactivated
	}
	return nil
}

func (x *DNSSECKey) GetDeleted() *timestamppb.Timestamp {
	if x != nil {
		return x.Deleted
	}
	return nil
}

func (x *DNSSECKey) GetExpires() *timestamppb.Timestamp {
	if x != nil {
		return x.Expires
	}
	return nil
}

func (x *DNSSECKey) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *DNSSECKey) GetHasPrivateKey() bool {
	if x != nil {
		return x.HasPrivateKey
	}
	return false
}

func (x *DNSSECKey) GetDsRecords() []*DSRecord {
	if x != nil {
		return x.DsRecords
	}
	return nil
}

func (x *DNSSECKey) GetKeySize() int32 {
	if x != nil {
		return x.KeySize
	}
	return 0
}

// DS Record
type DSRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	KeyTag        uint32                 `protobuf:"varint,1,opt,name=key_tag,json=keyTag,proto3" json:"key_tag,omitempty"`
	Algorithm     DNSSECAlgorithm        `protobuf:"varint,2,opt,name=algorithm,proto3,enum=dnsscience.v1.DNSSECAlgorithm" json:"algorithm,omitempty"`
	DigestType    uint32                 `protobuf:"varint,3,opt,name=digest_type,json=digestType,proto3" json:"digest_type,omitempty"` // 1=SHA-1, 2=SHA-256, 4=SHA-384
	Digest        string                 `protobuf:"bytes,4,opt,name=digest,proto3" json:"digest,omitempty"`                            // Hex encoded
	Record        string                 `protobuf:"bytes,5,opt,name=record,proto3" json:"record,omitempty"`                            // Full DS record string
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DSRecord) Reset() {
	*x = DSRecord{}
	mi := &file_dnssec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DSRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DSRecord) ProtoMessage() {}

func (x *DSRecord) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DSRecord.ProtoReflect.Descriptor instead.
func (*DSRecord) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{1}
}

func (x *DSRecord) GetKeyTag() uint32 {
	if x != nil {
		return x.KeyTag
	}
	return 0
}

func (x *DSRecord) GetAlgorithm() DNSSECAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return DNSSECAlgorithm_DNSSEC_ALGORITHM_UNSPECIFIED
}

func (x *DSRecord) GetDigestType() uint32 {
	if x != nil {
		return x.DigestType
	}
	return 0
}

func (x *DSRecord) GetDigest() string {
	if x != nil {
		return x.Digest
	}
	return ""
}

func (x *DSRecord) GetRecord() string {
	if x != nil {
		return x.Record
	}
	return ""
}

// DNSSECStatusRequest
type DNSSECStatusRequest struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	ZoneName             string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	IncludePublicKeyMode IncludeKeyMode         `protobuf:"varint,2,opt,name=include_public_key_mode,json=includePublicKeyMode,proto3,enum=dnsscience.v1.IncludeKeyMode" json:"include_public_key_mode,omitempty"` // default server-side: MAY
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *DNSSECStatusRequest) Reset() {
	*x = DNSSECStatusRequest{}
	mi := &file_dnssec_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSSECStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSSECStatusRequest) ProtoMessage() {}

func (x *DNSSECStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSSECStatusRequest.ProtoReflect.Descriptor instead.
func (*DNSSECStatusRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{2}
}

func (x *DNSSECStatusRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *DNSSECStatusRequest) GetIncludePublicKeyMode() IncludeKeyMode {
	if x != nil {
		return x.IncludePublicKeyMode
	}
	return IncludeKeyMode_INCLUDE_KEY_MODE_UNSPECIFIED
}

// DNSSECStatusResponse
type DNSSECStatusResponse struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	ZoneName  string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	Enabled   bool                   `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Signed    bool                   `protobuf:"varint,3,opt,name=signed,proto3" json:"signed,omitempty"`
	Algorithm DNSSECAlgorithm        `protobuf:"varint,4,opt,name=algorithm,proto3,enum=dnsscience.v1.DNSSECAlgorithm" json:"algorithm,omitempty"`
	Keys      []*DNSSECKey           `protobuf:"bytes,5,rep,name=keys,proto3" json:"keys,omitempty"`
	// Validation status
	LastValidation   *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=last_validation,json=lastValidation,proto3" json:"last_validation,omitempty"`
	ChainValid       bool                   `protobuf:"varint,7,opt,name=chain_valid,json=chainValid,proto3" json:"chain_valid,omitempty"`
	SignaturesValid  bool                   `protobuf:"varint,8,opt,name=signatures_valid,json=signaturesValid,proto3" json:"signatures_valid,omitempty"`
	ExpiringSoon     bool                   `protobuf:"varint,9,opt,name=expiring_soon,json=expiringSoon,proto3" json:"expiring_soon,omitempty"`
	ValidationErrors []string               `protobuf:"bytes,10,rep,name=validation_errors,json=validationErrors,proto3" json:"validation_errors,omitempty"`
	Meta             *ResponseMeta          `protobuf:"bytes,11,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DNSSECStatusResponse) Reset() {
	*x = DNSSECStatusResponse{}
	mi := &file_dnssec_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSSECStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSSECStatusResponse) ProtoMessage() {}

func (x *DNSSECStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSSECStatusResponse.ProtoReflect.Descriptor instead.
func (*DNSSECStatusResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{3}
}

func (x *DNSSECStatusResponse) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *DNSSECStatusResponse) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *DNSSECStatusResponse) GetSigned() bool {
	if x != nil {
		return x.Signed
	}
	return false
}

func (x *DNSSECStatusResponse) GetAlgorithm() DNSSECAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return DNSSECAlgorithm_DNSSEC_ALGORITHM_UNSPECIFIED
}

func (x *DNSSECStatusResponse) GetKeys() []*DNSSECKey {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *DNSSECStatusResponse) GetLastValidation() *timestamppb.Timestamp {
	if x != nil {
		return x.LastValidation
	}
	return nil
}

func (x *DNSSECStatusResponse) GetChainValid() bool {
	if x != nil {
		return x.ChainValid
	}
	return false
}

func (x *DNSSECStatusResponse) GetSignaturesValid() bool {
	if x != nil {
		return x.SignaturesValid
	}
	return false
}

func (x *DNSSECStatusResponse) GetExpiringSoon() bool {
	if x != nil {
		return x.ExpiringSoon
	}
	return false
}

func (x *DNSSECStatusResponse) GetValidationErrors() []string {
	if x != nil {
		return x.ValidationErrors
	}
	return nil
}

func (x *DNSSECStatusResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// SignZoneRequest
type SignZoneRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	ZoneName        string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	IncrementSerial bool                   `protobuf:"varint,2,opt,name=increment_serial,json=incrementSerial,proto3" json:"increment_serial,omitempty"` // Auto-increment zone serial
	ResignAll       bool                   `protobuf:"varint,3,opt,name=resign_all,json=resignAll,proto3" json:"resign_all,omitempty"`                   // Re-sign all existing signatures
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SignZoneRequest) Reset() {
	*x = SignZoneRequest{}
	mi := &file_dnssec_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignZoneRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignZoneRequest) ProtoMessage() {}

func (x *SignZoneRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignZoneRequest.ProtoReflect.Descriptor instead.
func (*SignZoneRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{4}
}

func (x *SignZoneRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *SignZoneRequest) GetIncrementSerial() bool {
	if x != nil {
		return x.IncrementSerial
	}
	return false
}

func (x *SignZoneRequest) GetResignAll() bool {
	if x != nil {
		return x.ResignAll
	}
	return false
}

// SignZoneResponse
type SignZoneResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	ZoneName          string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	Success           bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	OldSerial         uint32                 `protobuf:"varint,3,opt,name=old_serial,json=oldSerial,proto3" json:"old_serial,omitempty"`
	NewSerial         uint32                 `protobuf:"varint,4,opt,name=new_serial,json=newSerial,proto3" json:"new_serial,omitempty"`
	SignaturesCreated int32                  `protobuf:"varint,5,opt,name=signatures_created,json=signaturesCreated,proto3" json:"signatures_created,omitempty"`
	SignaturesUpdated int32                  `protobuf:"varint,6,opt,name=signatures_updated,json=signaturesUpdated,proto3" json:"signatures_updated,omitempty"`
	Duration          *durationpb.Duration   `protobuf:"bytes,7,opt,name=duration,proto3" json:"duration,omitempty"`
	Errors            []string               `protobuf:"bytes,8,rep,name=errors,proto3" json:"errors,omitempty"`
	Meta              *ResponseMeta          `protobuf:"bytes,9,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SignZoneResponse) Reset() {
	*x = SignZoneResponse{}
	mi := &file_dnssec_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignZoneResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignZoneResponse) ProtoMessage() {}

func (x *SignZoneResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignZoneResponse.ProtoReflect.Descriptor instead.
func (*SignZoneResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{5}
}

func (x *SignZoneResponse) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *SignZoneResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SignZoneResponse) GetOldSerial() uint32 {
	if x != nil {
		return x.OldSerial
	}
	return 0
}

func (x *SignZoneResponse) GetNewSerial() uint32 {
	if x != nil {
		return x.NewSerial
	}
	return 0
}

func (x *SignZoneResponse) GetSignaturesCreated() int32 {
	if x != nil {
		return x.SignaturesCreated
	}
	return 0
}

func (x *SignZoneResponse) GetSignaturesUpdated() int32 {
	if x != nil {
		return x.SignaturesUpdated
	}
	return 0
}

func (x *SignZoneResponse) GetDuration() *durationpb.Duration {
	if x != nil {
		return x.Duration
	}
	return nil
}

func (x *SignZoneResponse) GetErrors() []string {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *SignZoneResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// RolloverRequest
type RolloverRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ZoneName      string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	KeyType       KeyType                `protobuf:"varint,2,opt,name=key_type,json=keyType,proto3,enum=dnsscience.v1.KeyType" json:"key_type,omitempty"`                        // ksk or zsk
	NewAlgorithm  DNSSECAlgorithm        `protobuf:"varint,3,opt,name=new_algorithm,json=newAlgorithm,proto3,enum=dnsscience.v1.DNSSECAlgorithm" json:"new_algorithm,omitempty"` // Optional: change algorithm
	KeySize       int32                  `protobuf:"varint,4,opt,name=key_size,json=keySize,proto3" json:"key_size,omitempty"`                                                   // Optional: for RSA keys
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RolloverRequest) Reset() {
	*x = RolloverRequest{}
	mi := &file_dnssec_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RolloverRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RolloverRequest) ProtoMessage() {}

func (x *RolloverRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RolloverRequest.ProtoReflect.Descriptor instead.
func (*RolloverRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{6}
}

func (x *RolloverRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *RolloverRequest) GetKeyType() KeyType {
	if x != nil {
		return x.KeyType
	}
	return KeyType_KEY_TYPE_UNSPECIFIED
}

func (x *RolloverRequest) GetNewAlgorithm() DNSSECAlgorithm {
	if x != nil {
		return x.NewAlgorithm
	}
	return DNSSECAlgorithm_DNSSEC_ALGORITHM_UNSPECIFIED
}

func (x *RolloverRequest) GetKeySize() int32 {
	if x != nil {
		return x.KeySize
	}
	return 0
}

// RolloverResponse with timeline
type RolloverResponse struct {
	state         protoimpl.MessageState            `protogen:"open.v1"`
	ZoneName      string                            `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	KeyType       KeyType                           `protobuf:"varint,2,opt,name=key_type,json=keyType,proto3,enum=dnsscience.v1.KeyType" json:"key_type,omitempty"`
	Status        string                            `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"` // initiated, in_progress, completed
	OldKey        *DNSSECKey                        `protobuf:"bytes,4,opt,name=old_key,json=oldKey,proto3" json:"old_key,omitempty"`
	NewKey        *DNSSECKey                        `protobuf:"bytes,5,opt,name=new_key,json=newKey,proto3" json:"new_key,omitempty"`
	Timeline      []*RolloverResponse_RolloverPhase `protobuf:"bytes,6,rep,name=timeline,proto3" json:"timeline,omitempty"`
	Meta          *ResponseMeta                     `protobuf:"bytes,7,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RolloverResponse) Reset() {
	*x = RolloverResponse{}
	mi := &file_dnssec_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RolloverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RolloverResponse) ProtoMessage() {}

func (x *RolloverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RolloverResponse.ProtoReflect.Descriptor instead.
func (*RolloverResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{7}
}

func (x *RolloverResponse) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *RolloverResponse) GetKeyType() KeyType {
	if x != nil {
		return x.KeyType
	}
	return KeyType_KEY_TYPE_UNSPECIFIED
}

func (x *RolloverResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *RolloverResponse) GetOldKey() *DNSSECKey {
	if x != nil {
		return x.OldKey
	}
	return nil
}

func (x *RolloverResponse) GetNewKey() *DNSSECKey {
	if x != nil {
		return x.NewKey
	}
	return nil
}

func (x *RolloverResponse) GetTimeline() []*RolloverResponse_RolloverPhase {
	if x != nil {
		return x.Timeline
	}
	return nil
}

func (x *RolloverResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// GetDSRequest
type GetDSRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ZoneName      string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	KeyType       KeyType                `protobuf:"varint,2,opt,name=key_type,json=keyType,proto3,enum=dnsscience.v1.KeyType" json:"key_type,omitempty"` // Optional: filter by type
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetDSRequest) Reset() {
	*x = GetDSRequest{}
	mi := &file_dnssec_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetDSRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetDSRequest) ProtoMessage() {}

func (x *GetDSRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetDSRequest.ProtoReflect.Descriptor instead.
func (*GetDSRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{8}
}

func (x *GetDSRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *GetDSRequest) GetKeyType() KeyType {
	if x != nil {
		return x.KeyType
	}
	return KeyType_KEY_TYPE_UNSPECIFIED
}

// GetDSResponse
type GetDSResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ZoneName      string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	DsRecords     []*DSRecord            `protobuf:"bytes,2,rep,name=ds_records,json=dsRecords,proto3" json:"ds_records,omitempty"`
	Meta          *ResponseMeta          `protobuf:"bytes,3,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetDSResponse) Reset() {
	*x = GetDSResponse{}
	mi := &file_dnssec_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetDSResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetDSResponse) ProtoMessage() {}

func (x *GetDSResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetDSResponse.ProtoReflect.Descriptor instead.
func (*GetDSResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{9}
}

func (x *GetDSResponse) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *GetDSResponse) GetDsRecords() []*DSRecord {
	if x != nil {
		return x.DsRecords
	}
	return nil
}

func (x *GetDSResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// GenerateKeyRequest
type GenerateKeyRequest struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	ZoneName            string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	Type                KeyType                `protobuf:"varint,2,opt,name=type,proto3,enum=dnsscience.v1.KeyType" json:"type,omitempty"`
	Algorithm           DNSSECAlgorithm        `protobuf:"varint,3,opt,name=algorithm,proto3,enum=dnsscience.v1.DNSSECAlgorithm" json:"algorithm,omitempty"`
	KeySize             int32                  `protobuf:"varint,4,opt,name=key_size,json=keySize,proto3" json:"key_size,omitempty"` // For RSA algorithms
	ActivateImmediately bool                   `protobuf:"varint,5,opt,name=activate_immediately,json=activateImmediately,proto3" json:"activate_immediately,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *GenerateKeyRequest) Reset() {
	*x = GenerateKeyRequest{}
	mi := &file_dnssec_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenerateKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenerateKeyRequest) ProtoMessage() {}

func (x *GenerateKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenerateKeyRequest.ProtoReflect.Descriptor instead.
func (*GenerateKeyRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{10}
}

func (x *GenerateKeyRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *GenerateKeyRequest) GetType() KeyType {
	if x != nil {
		return x.Type
	}
	return KeyType_KEY_TYPE_UNSPECIFIED
}

func (x *GenerateKeyRequest) GetAlgorithm() DNSSECAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return DNSSECAlgorithm_DNSSEC_ALGORITHM_UNSPECIFIED
}

func (x *GenerateKeyRequest) GetKeySize() int32 {
	if x != nil {
		return x.KeySize
	}
	return 0
}

func (x *GenerateKeyRequest) GetActivateImmediately() bool {
	if x != nil {
		return x.ActivateImmediately
	}
	return false
}

// GenerateKeyResponse
type GenerateKeyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           *DNSSECKey             `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	PublicKey     string                 `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	PrivateKey    string                 `protobuf:"bytes,3,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"` // Only in response, never stored in DB
	DsRecords     []*DSRecord            `protobuf:"bytes,4,rep,name=ds_records,json=dsRecords,proto3" json:"ds_records,omitempty"`
	Meta          *ResponseMeta          `protobuf:"bytes,5,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GenerateKeyResponse) Reset() {
	*x = GenerateKeyResponse{}
	mi := &file_dnssec_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenerateKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenerateKeyResponse) ProtoMessage() {}

func (x *GenerateKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenerateKeyResponse.ProtoReflect.Descriptor instead.
func (*GenerateKeyResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{11}
}

func (x *GenerateKeyResponse) GetKey() *DNSSECKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *GenerateKeyResponse) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *GenerateKeyResponse) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

func (x *GenerateKeyResponse) GetDsRecords() []*DSRecord {
	if x != nil {
		return x.DsRecords
	}
	return nil
}

func (x *GenerateKeyResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// ImportKeyRequest
type ImportKeyRequest struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	ZoneName            string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	Type                KeyType                `protobuf:"varint,2,opt,name=type,proto3,enum=dnsscience.v1.KeyType" json:"type,omitempty"`
	Algorithm           DNSSECAlgorithm        `protobuf:"varint,3,opt,name=algorithm,proto3,enum=dnsscience.v1.DNSSECAlgorithm" json:"algorithm,omitempty"`
	PublicKey           string                 `protobuf:"bytes,4,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`    // Base64 encoded
	PrivateKey          string                 `protobuf:"bytes,5,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"` // Base64 encoded (optional)
	ActivateImmediately bool                   `protobuf:"varint,6,opt,name=activate_immediately,json=activateImmediately,proto3" json:"activate_immediately,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ImportKeyRequest) Reset() {
	*x = ImportKeyRequest{}
	mi := &file_dnssec_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImportKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImportKeyRequest) ProtoMessage() {}

func (x *ImportKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImportKeyRequest.ProtoReflect.Descriptor instead.
func (*ImportKeyRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{12}
}

func (x *ImportKeyRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *ImportKeyRequest) GetType() KeyType {
	if x != nil {
		return x.Type
	}
	return KeyType_KEY_TYPE_UNSPECIFIED
}

func (x *ImportKeyRequest) GetAlgorithm() DNSSECAlgorithm {
	if x != nil {
		return x.Algorithm
	}
	return DNSSECAlgorithm_DNSSEC_ALGORITHM_UNSPECIFIED
}

func (x *ImportKeyRequest) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *ImportKeyRequest) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

func (x *ImportKeyRequest) GetActivateImmediately() bool {
	if x != nil {
		return x.ActivateImmediately
	}
	return false
}

// ImportKeyResponse
type ImportKeyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           *DNSSECKey             `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	HasPrivate    bool                   `protobuf:"varint,2,opt,name=has_private,json=hasPrivate,proto3" json:"has_private,omitempty"`
	Meta          *ResponseMeta          `protobuf:"bytes,3,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ImportKeyResponse) Reset() {
	*x = ImportKeyResponse{}
	mi := &file_dnssec_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ImportKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ImportKeyResponse) ProtoMessage() {}

func (x *ImportKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ImportKeyResponse.ProtoReflect.Descriptor instead.
func (*ImportKeyResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{13}
}

func (x *ImportKeyResponse) GetKey() *DNSSECKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *ImportKeyResponse) GetHasPrivate() bool {
	if x != nil {
		return x.HasPrivate
	}
	return false
}

func (x *ImportKeyResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// ExportKeyRequest
type ExportKeyRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ZoneName       string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	KeyId          string                 `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	IncludePrivate bool                   `protobuf:"varint,3,opt,name=include_private,json=includePrivate,proto3" json:"include_private,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ExportKeyRequest) Reset() {
	*x = ExportKeyRequest{}
	mi := &file_dnssec_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportKeyRequest) ProtoMessage() {}

func (x *ExportKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExportKeyRequest.ProtoReflect.Descriptor instead.
func (*ExportKeyRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{14}
}

func (x *ExportKeyRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *ExportKeyRequest) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *ExportKeyRequest) GetIncludePrivate() bool {
	if x != nil {
		return x.IncludePrivate
	}
	return false
}

// ExportKeyResponse
type ExportKeyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           *DNSSECKey             `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	PublicKey     string                 `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	PrivateKey    string                 `protobuf:"bytes,3,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"` // Only if requested and available
	Meta          *ResponseMeta          `protobuf:"bytes,4,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExportKeyResponse) Reset() {
	*x = ExportKeyResponse{}
	mi := &file_dnssec_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExportKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExportKeyResponse) ProtoMessage() {}

func (x *ExportKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExportKeyResponse.ProtoReflect.Descriptor instead.
func (*ExportKeyResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{15}
}

func (x *ExportKeyResponse) GetKey() *DNSSECKey {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *ExportKeyResponse) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *ExportKeyResponse) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

func (x *ExportKeyResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// DeleteKeyRequest
type DeleteKeyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ZoneName      string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	KeyId         string                 `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Force         bool                   `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"` // Force deletion even if active
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteKeyRequest) Reset() {
	*x = DeleteKeyRequest{}
	mi := &file_dnssec_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteKeyRequest) ProtoMessage() {}

func (x *DeleteKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteKeyRequest.ProtoReflect.Descriptor instead.
func (*DeleteKeyRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{16}
}

func (x *DeleteKeyRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *DeleteKeyRequest) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *DeleteKeyRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// DeleteKeyResponse
type DeleteKeyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	KeyId         string                 `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Meta          *ResponseMeta          `protobuf:"bytes,4,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteKeyResponse) Reset() {
	*x = DeleteKeyResponse{}
	mi := &file_dnssec_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteKeyResponse) ProtoMessage() {}

func (x *DeleteKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteKeyResponse.ProtoReflect.Descriptor instead.
func (*DeleteKeyResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{17}
}

func (x *DeleteKeyResponse) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *DeleteKeyResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DeleteKeyResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *DeleteKeyResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// ValidateChainRequest
type ValidateChainRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ZoneName      string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	TrustAnchors  []string               `protobuf:"bytes,2,rep,name=trust_anchors,json=trustAnchors,proto3" json:"trust_anchors,omitempty"` // Optional: override trust anchors
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateChainRequest) Reset() {
	*x = ValidateChainRequest{}
	mi := &file_dnssec_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateChainRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateChainRequest) ProtoMessage() {}

func (x *ValidateChainRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateChainRequest.ProtoReflect.Descriptor instead.
func (*ValidateChainRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{18}
}

func (x *ValidateChainRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *ValidateChainRequest) GetTrustAnchors() []string {
	if x != nil {
		return x.TrustAnchors
	}
	return nil
}

// ValidateChainResponse
type ValidateChainResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ZoneName       string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	Valid          bool                   `protobuf:"varint,2,opt,name=valid,proto3" json:"valid,omitempty"`
	ValidationPath []string               `protobuf:"bytes,3,rep,name=validation_path,json=validationPath,proto3" json:"validation_path,omitempty"` // Chain path
	Errors         []string               `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
	Meta           *ResponseMeta          `protobuf:"bytes,5,opt,name=meta,proto3" json:"meta,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ValidateChainResponse) Reset() {
	*x = ValidateChainResponse{}
	mi := &file_dnssec_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateChainResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateChainResponse) ProtoMessage() {}

func (x *ValidateChainResponse) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateChainResponse.ProtoReflect.Descriptor instead.
func (*ValidateChainResponse) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{19}
}

func (x *ValidateChainResponse) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *ValidateChainResponse) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *ValidateChainResponse) GetValidationPath() []string {
	if x != nil {
		return x.ValidationPath
	}
	return nil
}

func (x *ValidateChainResponse) GetErrors() []string {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *ValidateChainResponse) GetMeta() *ResponseMeta {
	if x != nil {
		return x.Meta
	}
	return nil
}

// WatchKeysRequest for DNSSEC key event streaming
type WatchKeysRequest struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	ZoneName             string                 `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	EventTypes           []string               `protobuf:"bytes,2,rep,name=event_types,json=eventTypes,proto3" json:"event_types,omitempty"`                                                                      // key_created, key_activated, key_expiring, key_deleted
	IncludePublicKeyMode IncludeKeyMode         `protobuf:"varint,3,opt,name=include_public_key_mode,json=includePublicKeyMode,proto3,enum=dnsscience.v1.IncludeKeyMode" json:"include_public_key_mode,omitempty"` // default server-side: MAY
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *WatchKeysRequest) Reset() {
	*x = WatchKeysRequest{}
	mi := &file_dnssec_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WatchKeysRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WatchKeysRequest) ProtoMessage() {}

func (x *WatchKeysRequest) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WatchKeysRequest.ProtoReflect.Descriptor instead.
func (*WatchKeysRequest) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{20}
}

func (x *WatchKeysRequest) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *WatchKeysRequest) GetEventTypes() []string {
	if x != nil {
		return x.EventTypes
	}
	return nil
}

func (x *WatchKeysRequest) GetIncludePublicKeyMode() IncludeKeyMode {
	if x != nil {
		return x.IncludePublicKeyMode
	}
	return IncludeKeyMode_INCLUDE_KEY_MODE_UNSPECIFIED
}

// DNSSECEvent represents a DNSSEC operation event
type DNSSECEvent struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Type      DNSSECEvent_EventType  `protobuf:"varint,1,opt,name=type,proto3,enum=dnsscience.v1.DNSSECEvent_EventType" json:"type,omitempty"`
	ZoneName  string                 `protobuf:"bytes,2,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Types that are valid to be assigned to Detail:
	//
	//	*DNSSECEvent_Key
	//	*DNSSECEvent_ErrorMessage
	Detail        isDNSSECEvent_Detail `protobuf_oneof:"detail"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DNSSECEvent) Reset() {
	*x = DNSSECEvent{}
	mi := &file_dnssec_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DNSSECEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DNSSECEvent) ProtoMessage() {}

func (x *DNSSECEvent) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DNSSECEvent.ProtoReflect.Descriptor instead.
func (*DNSSECEvent) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{21}
}

func (x *DNSSECEvent) GetType() DNSSECEvent_EventType {
	if x != nil {
		return x.Type
	}
	return DNSSECEvent_EVENT_TYPE_UNSPECIFIED
}

func (x *DNSSECEvent) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

func (x *DNSSECEvent) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *DNSSECEvent) GetDetail() isDNSSECEvent_Detail {
	if x != nil {
		return x.Detail
	}
	return nil
}

func (x *DNSSECEvent) GetKey() *DNSSECKey {
	if x != nil {
		if x, ok := x.Detail.(*DNSSECEvent_Key); ok {
			return x.Key
		}
	}
	return nil
}

func (x *DNSSECEvent) GetErrorMessage() string {
	if x != nil {
		if x, ok := x.Detail.(*DNSSECEvent_ErrorMessage); ok {
			return x.ErrorMessage
		}
	}
	return ""
}

type isDNSSECEvent_Detail interface {
	isDNSSECEvent_Detail()
}

type DNSSECEvent_Key struct {
	Key *DNSSECKey `protobuf:"bytes,4,opt,name=key,proto3,oneof"`
}

type DNSSECEvent_ErrorMessage struct {
	ErrorMessage string `protobuf:"bytes,5,opt,name=error_message,json=errorMessage,proto3,oneof"`
}

func (*DNSSECEvent_Key) isDNSSECEvent_Detail() {}

func (*DNSSECEvent_ErrorMessage) isDNSSECEvent_Detail() {}

type RolloverResponse_RolloverPhase struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Phase         string                 `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty"` // publish, activate, retire_old, delete_old
	ScheduledDate *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=scheduled_date,json=scheduledDate,proto3" json:"scheduled_date,omitempty"`
	CompletedDate *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=completed_date,json=completedDate,proto3" json:"completed_date,omitempty"`
	Status        string                 `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"` // pending, in_progress, completed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RolloverResponse_RolloverPhase) Reset() {
	*x = RolloverResponse_RolloverPhase{}
	mi := &file_dnssec_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RolloverResponse_RolloverPhase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RolloverResponse_RolloverPhase) ProtoMessage() {}

func (x *RolloverResponse_RolloverPhase) ProtoReflect() protoreflect.Message {
	mi := &file_dnssec_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RolloverResponse_RolloverPhase.ProtoReflect.Descriptor instead.
func (*RolloverResponse_RolloverPhase) Descriptor() ([]byte, []int) {
	return file_dnssec_proto_rawDescGZIP(), []int{7, 0}
}

func (x *RolloverResponse_RolloverPhase) GetPhase() string {
	if x != nil {
		return x.Phase
	}
	return ""
}

func (x *RolloverResponse_RolloverPhase) GetScheduledDate() *timestamppb.Timestamp {
	if x != nil {
		return x.ScheduledDate
	}
	return nil
}

func (x *RolloverResponse_RolloverPhase) GetCompletedDate() *timestamppb.Timestamp {
	if x != nil {
		return x.CompletedDate
	}
	return nil
}

func (x *RolloverResponse_RolloverPhase) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

var File_dnssec_proto protoreflect.FileDescriptor

const file_dnssec_proto_rawDesc = "" +
	"\n" +
	"\fdnssec.proto\x12\rdnsscience.v1\x1a\fcommon.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/duration.proto\"\x84\x05\n" +
	"\tDNSSECKey\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x17\n" +
	"\akey_tag\x18\x02 \x01(\rR\x06keyTag\x12*\n" +
	"\x04type\x18\x03 \x01(\x0e2\x16.dnsscience.v1.KeyTypeR\x04type\x12<\n" +
	"\talgorithm\x18\x04 \x01(\x0e2\x1e.dnsscience.v1.DNSSECAlgorithmR\talgorithm\x120\n" +
	"\x06status\x18\x05 \x01(\x0e2\x18.dnsscience.v1.KeyStatusR\x06status\x124\n" +
	"\acreated\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\acreated\x128\n" +
	"\tactivated\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\tactivated\x12<\n" +
	"\vinactivated\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\vinactivated\x124\n" +
	"\adeleted\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\adeleted\x124\n" +
	"\aexpires\x18\n" +
	" \x01(\v2\x1a.google.protobuf.TimestampR\aexpires\x12\x1d\n" +
	"\n" +
	"public_key\x18\v \x01(\tR\tpublicKey\x12&\n" +
	"\x0fhas_private_key\x18\f \x01(\bR\rhasPrivateKey\x126\n" +
	"\n" +
	"ds_records\x18\r \x03(\v2\x17.dnsscience.v1.DSRecordR\tdsRecords\x12\x19\n" +
	"\bkey_size\x18\x0e \x01(\x05R\akeySize\"\xb2\x01\n" +
	"\bDSRecord\x12\x17\n" +
	"\akey_tag\x18\x01 \x01(\rR\x06keyTag\x12<\n" +
	"\talgorithm\x18\x02 \x01(\x0e2\x1e.dnsscience.v1.DNSSECAlgorithmR\talgorithm\x12\x1f\n" +
	"\vdigest_type\x18\x03 \x01(\rR\n" +
	"digestType\x12\x16\n" +
	"\x06digest\x18\x04 \x01(\tR\x06digest\x12\x16\n" +
	"\x06record\x18\x05 \x01(\tR\x06record\"\x88\x01\n" +
	"\x13DNSSECStatusRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12T\n" +
	"\x17include_public_key_mode\x18\x02 \x01(\x0e2\x1d.dnsscience.v1.IncludeKeyModeR\x14includePublicKeyMode\"\xe5\x03\n" +
	"\x14DNSSECStatusResponse\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12\x18\n" +
	"\aenabled\x18\x02 \x01(\bR\aenabled\x12\x16\n" +
	"\x06signed\x18\x03 \x01(\bR\x06signed\x12<\n" +
	"\talgorithm\x18\x04 \x01(\x0e2\x1e.dnsscience.v1.DNSSECAlgorithmR\talgorithm\x12,\n" +
	"\x04keys\x18\x05 \x03(\v2\x18.dnsscience.v1.DNSSECKeyR\x04keys\x12C\n" +
	"\x0flast_validation\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x0elastValidation\x12\x1f\n" +
	"\vchain_valid\x18\a \x01(\bR\n" +
	"chainValid\x12)\n" +
	"\x10signatures_valid\x18\b \x01(\bR\x0fsignaturesValid\x12#\n" +
	"\rexpiring_soon\x18\t \x01(\bR\fexpiringSoon\x12+\n" +
	"\x11validation_errors\x18\n" +
	" \x03(\tR\x10validationErrors\x12/\n" +
	"\x04meta\x18\v \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\"x\n" +
	"\x0fSignZoneRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12)\n" +
	"\x10increment_serial\x18\x02 \x01(\bR\x0fincrementSerial\x12\x1d\n" +
	"\n" +
	"resign_all\x18\x03 \x01(\bR\tresignAll\"\xe5\x02\n" +
	"\x10SignZoneResponse\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x12\x1d\n" +
	"\n" +
	"old_serial\x18\x03 \x01(\rR\toldSerial\x12\x1d\n" +
	"\n" +
	"new_serial\x18\x04 \x01(\rR\tnewSerial\x12-\n" +
	"\x12signatures_created\x18\x05 \x01(\x05R\x11signaturesCreated\x12-\n" +
	"\x12signatures_updated\x18\x06 \x01(\x05R\x11signaturesUpdated\x125\n" +
	"\bduration\x18\a \x01(\v2\x19.google.protobuf.DurationR\bduration\x12\x16\n" +
	"\x06errors\x18\b \x03(\tR\x06errors\x12/\n" +
	"\x04meta\x18\t \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\"\xc1\x01\n" +
	"\x0fRolloverRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x121\n" +
	"\bkey_type\x18\x02 \x01(\x0e2\x16.dnsscience.v1.KeyTypeR\akeyType\x12C\n" +
	"\rnew_algorithm\x18\x03 \x01(\x0e2\x1e.dnsscience.v1.DNSSECAlgorithmR\fnewAlgorithm\x12\x19\n" +
	"\bkey_size\x18\x04 \x01(\x05R\akeySize\"\xa2\x04\n" +
	"\x10RolloverResponse\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x121\n" +
	"\bkey_type\x18\x02 \x01(\x0e2\x16.dnsscience.v1.KeyTypeR\akeyType\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x121\n" +
	"\aold_key\x18\x04 \x01(\v2\x18.dnsscience.v1.DNSSECKeyR\x06oldKey\x121\n" +
	"\anew_key\x18\x05 \x01(\v2\x18.dnsscience.v1.DNSSECKeyR\x06newKey\x12I\n" +
	"\btimeline\x18\x06 \x03(\v2-.dnsscience.v1.RolloverResponse.RolloverPhaseR\btimeline\x12/\n" +
	"\x04meta\x18\a \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\x1a\xc3\x01\n" +
	"\rRolloverPhase\x12\x14\n" +
	"\x05phase\x18\x01 \x01(\tR\x05phase\x12A\n" +
	"\x0escheduled_date\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\rscheduledDate\x12A\n" +
	"\x0ecompleted_date\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\rcompletedDate\x12\x16\n" +
	"\x06status\x18\x04 \x01(\tR\x06status\"^\n" +
	"\fGetDSRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x121\n" +
	"\bkey_type\x18\x02 \x01(\x0e2\x16.dnsscience.v1.KeyTypeR\akeyType\"\x95\x01\n" +
	"\rGetDSResponse\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x126\n" +
	"\n" +
	"ds_records\x18\x02 \x03(\v2\x17.dnsscience.v1.DSRecordR\tdsRecords\x12/\n" +
	"\x04meta\x18\x03 \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\"\xe9\x01\n" +
	"\x12GenerateKeyRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12*\n" +
	"\x04type\x18\x02 \x01(\x0e2\x16.dnsscience.v1.KeyTypeR\x04type\x12<\n" +
	"\talgorithm\x18\x03 \x01(\x0e2\x1e.dnsscience.v1.DNSSECAlgorithmR\talgorithm\x12\x19\n" +
	"\bkey_size\x18\x04 \x01(\x05R\akeySize\x121\n" +
	"\x14activate_immediately\x18\x05 \x01(\bR\x13activateImmediately\"\xea\x01\n" +
	"\x13GenerateKeyResponse\x12*\n" +
	"\x03key\x18\x01 \x01(\v2\x18.dnsscience.v1.DNSSECKeyR\x03key\x12\x1d\n" +
	"\n" +
	"public_key\x18\x02 \x01(\tR\tpublicKey\x12\x1f\n" +
	"\vprivate_key\x18\x03 \x01(\tR\n" +
	"privateKey\x126\n" +
	"\n" +
	"ds_records\x18\x04 \x03(\v2\x17.dnsscience.v1.DSRecordR\tdsRecords\x12/\n" +
	"\x04meta\x18\x05 \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\"\x8c\x02\n" +
	"\x10ImportKeyRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12*\n" +
	"\x04type\x18\x02 \x01(\x0e2\x16.dnsscience.v1.KeyTypeR\x04type\x12<\n" +
	"\talgorithm\x18\x03 \x01(\x0e2\x1e.dnsscience.v1.DNSSECAlgorithmR\talgorithm\x12\x1d\n" +
	"\n" +
	"public_key\x18\x04 \x01(\tR\tpublicKey\x12\x1f\n" +
	"\vprivate_key\x18\x05 \x01(\tR\n" +
	"privateKey\x121\n" +
	"\x14activate_immediately\x18\x06 \x01(\bR\x13activateImmediately\"\x91\x01\n" +
	"\x11ImportKeyResponse\x12*\n" +
	"\x03key\x18\x01 \x01(\v2\x18.dnsscience.v1.DNSSECKeyR\x03key\x12\x1f\n" +
	"\vhas_private\x18\x02 \x01(\bR\n" +
	"hasPrivate\x12/\n" +
	"\x04meta\x18\x03 \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\"o\n" +
	"\x10ExportKeyRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12\x15\n" +
	"\x06key_id\x18\x02 \x01(\tR\x05keyId\x12'\n" +
	"\x0finclude_private\x18\x03 \x01(\bR\x0eincludePrivate\"\xb0\x01\n" +
	"\x11ExportKeyResponse\x12*\n" +
	"\x03key\x18\x01 \x01(\v2\x18.dnsscience.v1.DNSSECKeyR\x03key\x12\x1d\n" +
	"\n" +
	"public_key\x18\x02 \x01(\tR\tpublicKey\x12\x1f\n" +
	"\vprivate_key\x18\x03 \x01(\tR\n" +
	"privateKey\x12/\n" +
	"\x04meta\x18\x04 \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\"\\\n" +
	"\x10DeleteKeyRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12\x15\n" +
	"\x06key_id\x18\x02 \x01(\tR\x05keyId\x12\x14\n" +
	"\x05force\x18\x03 \x01(\bR\x05force\"\x8f\x01\n" +
	"\x11DeleteKeyResponse\x12\x15\n" +
	"\x06key_id\x18\x01 \x01(\tR\x05keyId\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\x12/\n" +
	"\x04meta\x18\x04 \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\"X\n" +
	"\x14ValidateChainRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12#\n" +
	"\rtrust_anchors\x18\x02 \x03(\tR\ftrustAnchors\"\xbc\x01\n" +
	"\x15ValidateChainResponse\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12\x14\n" +
	"\x05valid\x18\x02 \x01(\bR\x05valid\x12'\n" +
	"\x0fvalidation_path\x18\x03 \x03(\tR\x0evalidationPath\x12\x16\n" +
	"\x06errors\x18\x04 \x03(\tR\x06errors\x12/\n" +
	"\x04meta\x18\x05 \x01(\v2\x1b.dnsscience.v1.ResponseMetaR\x04meta\"\xa6\x01\n" +
	"\x10WatchKeysRequest\x12\x1b\n" +
	"\tzone_name\x18\x01 \x01(\tR\bzoneName\x12\x1f\n" +
	"\vevent_types\x18\x02 \x03(\tR\n" +
	"eventTypes\x12T\n" +
	"\x17include_public_key_mode\x18\x03 \x01(\x0e2\x1d.dnsscience.v1.IncludeKeyModeR\x14includePublicKeyMode\"\xbc\x04\n" +
	"\vDNSSECEvent\x128\n" +
	"\x04type\x18\x01 \x01(\x0e2$.dnsscience.v1.DNSSECEvent.EventTypeR\x04type\x12\x1b\n" +
	"\tzone_name\x18\x02 \x01(\tR\bzoneName\x128\n" +
	"\ttimestamp\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12,\n" +
	"\x03key\x18\x04 \x01(\v2\x18.dnsscience.v1.DNSSECKeyH\x00R\x03key\x12%\n" +
	"\rerror_message\x18\x05 \x01(\tH\x00R\ferrorMessage\"\xbc\x02\n" +
	"\tEventType\x12\x1a\n" +
	"\x16EVENT_TYPE_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16EVENT_TYPE_KEY_CREATED\x10\x01\x12\x1c\n" +
	"\x18EVENT_TYPE_KEY_ACTIVATED\x10\x02\x12\x1e\n" +
	"\x1aEVENT_TYPE_KEY_INACTIVATED\x10\x03\x12\x1a\n" +
	"\x16EVENT_TYPE_KEY_DELETED\x10\x04\x12\x1b\n" +
	"\x17EVENT_TYPE_KEY_EXPIRING\x10\x05\x12\x1f\n" +
	"\x1bEVENT_TYPE_ROLLOVER_STARTED\x10\x06\x12!\n" +
	"\x1dEVENT_TYPE_ROLLOVER_COMPLETED\x10\a\x12\x1a\n" +
	"\x16EVENT_TYPE_ZONE_SIGNED\x10\b\x12 \n" +
	"\x1cEVENT_TYPE_VALIDATION_FAILED\x10\tB\b\n" +
	"\x06detail*\xf9\x01\n" +
	"\x0fDNSSECAlgorithm\x12 \n" +
	"\x1cDNSSEC_ALGORITHM_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aDNSSEC_ALGORITHM_RSASHA256\x10\b\x12\x1e\n" +
	"\x1aDNSSEC_ALGORITHM_RSASHA512\x10\n" +
	"\x12$\n" +
	" DNSSEC_ALGORITHM_ECDSAP256SHA256\x10\r\x12$\n" +
	" DNSSEC_ALGORITHM_ECDSAP384SHA384\x10\x0e\x12\x1c\n" +
	"\x18DNSSEC_ALGORITHM_ED25519\x10\x0f\x12\x1a\n" +
	"\x16DNSSEC_ALGORITHM_ED448\x10\x10*G\n" +
	"\aKeyType\x12\x18\n" +
	"\x14KEY_TYPE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fKEY_TYPE_KSK\x10\x01\x12\x10\n" +
	"\fKEY_TYPE_ZSK\x10\x02*\xa0\x01\n" +
	"\tKeyStatus\x12\x1a\n" +
	"\x16KEY_STATUS_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11KEY_STATUS_ACTIVE\x10\x01\x12\x18\n" +
	"\x14KEY_STATUS_PUBLISHED\x10\x02\x12\x16\n" +
	"\x12KEY_STATUS_RETIRED\x10\x03\x12\x16\n" +
	"\x12KEY_STATUS_REVOKED\x10\x04\x12\x16\n" +
	"\x12KEY_STATUS_DELETED\x10\x05*\x7f\n" +
	"\x0eIncludeKeyMode\x12 \n" +
	"\x1cINCLUDE_KEY_MODE_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14INCLUDE_KEY_MODE_OFF\x10\x01\x12\x18\n" +
	"\x14INCLUDE_KEY_MODE_MAY\x10\x02\x12\x17\n" +
	"\x13INCLUDE_KEY_MODE_ON\x10\x032\xad\x06\n" +
	"\rDNSSECService\x12T\n" +
	"\tGetStatus\x12\".dnsscience.v1.DNSSECStatusRequest\x1a#.dnsscience.v1.DNSSECStatusResponse\x12G\n" +
	"\x04Sign\x12\x1e.dnsscience.v1.SignZoneRequest\x1a\x1f.dnsscience.v1.SignZoneResponse\x12K\n" +
	"\bRollover\x12\x1e.dnsscience.v1.RolloverRequest\x1a\x1f.dnsscience.v1.RolloverResponse\x12B\n" +
	"\x05GetDS\x12\x1b.dnsscience.v1.GetDSRequest\x1a\x1c.dnsscience.v1.GetDSResponse\x12T\n" +
	"\vGenerateKey\x12!.dnsscience.v1.GenerateKeyRequest\x1a\".dnsscience.v1.GenerateKeyResponse\x12N\n" +
	"\tImportKey\x12\x1f.dnsscience.v1.ImportKeyRequest\x1a .dnsscience.v1.ImportKeyResponse\x12N\n" +
	"\tExportKey\x12\x1f.dnsscience.v1.ExportKeyRequest\x1a .dnsscience.v1.ExportKeyResponse\x12N\n" +
	"\tDeleteKey\x12\x1f.dnsscience.v1.DeleteKeyRequest\x1a .dnsscience.v1.DeleteKeyResponse\x12Z\n" +
	"\rValidateChain\x12#.dnsscience.v1.ValidateChainRequest\x1a$.dnsscience.v1.ValidateChainResponse\x12J\n" +
	"\tWatchKeys\x12\x1f.dnsscience.v1.WatchKeysRequest\x1a\x1a.dnsscience.v1.DNSSECEvent0\x01B5Z3github.com/dnsscience/dnsscienced/api/grpc/proto/pbb\x06proto3"

var (
	file_dnssec_proto_rawDescOnce sync.Once
	file_dnssec_proto_rawDescData []byte
)

func file_dnssec_proto_rawDescGZIP() []byte {
	file_dnssec_proto_rawDescOnce.Do(func() {
		file_dnssec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_dnssec_proto_rawDesc), len(file_dnssec_proto_rawDesc)))
	})
	return file_dnssec_proto_rawDescData
}

var file_dnssec_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_dnssec_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_dnssec_proto_goTypes = []any{
	(DNSSECAlgorithm)(0),                   // 0: dnsscience.v1.DNSSECAlgorithm
	(KeyType)(0),                           // 1: dnsscience.v1.KeyType
	(KeyStatus)(0),                         // 2: dnsscience.v1.KeyStatus
	(IncludeKeyMode)(0),                    // 3: dnsscience.v1.IncludeKeyMode
	(DNSSECEvent_EventType)(0),             // 4: dnsscience.v1.DNSSECEvent.EventType
	(*DNSSECKey)(nil),                      // 5: dnsscience.v1.DNSSECKey
	(*DSRecord)(nil),                       // 6: dnsscience.v1.DSRecord
	(*DNSSECStatusRequest)(nil),            // 7: dnsscience.v1.DNSSECStatusRequest
	(*DNSSECStatusResponse)(nil),           // 8: dnsscience.v1.DNSSECStatusResponse
	(*SignZoneRequest)(nil),                // 9: dnsscience.v1.SignZoneRequest
	(*SignZoneResponse)(nil),               // 10: dnsscience.v1.SignZoneResponse
	(*RolloverRequest)(nil),                // 11: dnsscience.v1.RolloverRequest
	(*RolloverResponse)(nil),               // 12: dnsscience.v1.RolloverResponse
	(*GetDSRequest)(nil),                   // 13: dnsscience.v1.GetDSRequest
	(*GetDSResponse)(nil),                  // 14: dnsscience.v1.GetDSResponse
	(*GenerateKeyRequest)(nil),             // 15: dnsscience.v1.GenerateKeyRequest
	(*GenerateKeyResponse)(nil),            // 16: dnsscience.v1.GenerateKeyResponse
	(*ImportKeyRequest)(nil),               // 17: dnsscience.v1.ImportKeyRequest
	(*ImportKeyResponse)(nil),              // 18: dnsscience.v1.ImportKeyResponse
	(*ExportKeyRequest)(nil),               // 19: dnsscience.v1.ExportKeyRequest
	(*ExportKeyResponse)(nil),              // 20: dnsscience.v1.ExportKeyResponse
	(*DeleteKeyRequest)(nil),               // 21: dnsscience.v1.DeleteKeyRequest
	(*DeleteKeyResponse)(nil),              // 22: dnsscience.v1.DeleteKeyResponse
	(*ValidateChainRequest)(nil),           // 23: dnsscience.v1.ValidateChainRequest
	(*ValidateChainResponse)(nil),          // 24: dnsscience.v1.ValidateChainResponse
	(*WatchKeysRequest)(nil),               // 25: dnsscience.v1.WatchKeysRequest
	(*DNSSECEvent)(nil),                    // 26: dnsscience.v1.DNSSECEvent
	(*RolloverResponse_RolloverPhase)(nil), // 27: dnsscience.v1.RolloverResponse.RolloverPhase
	(*timestamppb.Timestamp)(nil),          // 28: google.protobuf.Timestamp
	(*ResponseMeta)(nil),                   // 29: dnsscience.v1.ResponseMeta
	(*durationpb.Duration)(nil),            // 30: google.protobuf.Duration
}
var file_dnssec_proto_depIdxs = []int32{
	1,  // 0: dnsscience.v1.DNSSECKey.type:type_name -> dnsscience.v1.KeyType
	0,  // 1: dnsscience.v1.DNSSECKey.algorithm:type_name -> dnsscience.v1.DNSSECAlgorithm
	2,  // 2: dnsscience.v1.DNSSECKey.status:type_name -> dnsscience.v1.KeyStatus
	28, // 3: dnsscience.v1.DNSSECKey.created:type_name -> google.protobuf.Timestamp
	28, // 4: dnsscience.v1.DNSSECKey.activated:type_name -> google.protobuf.Timestamp
	28, // 5: dnsscience.v1.DNSSECKey.inactivated:type_name -> google.protobuf.Timestamp
	28, // 6: dnsscience.v1.DNSSECKey.deleted:type_name -> google.protobuf.Timestamp
	28, // 7: dnsscience.v1.DNSSECKey.expires:type_name -> google.protobuf.Timestamp
	6,  // 8: dnsscience.v1.DNSSECKey.ds_records:type_name -> dnsscience.v1.DSRecord
	0,  // 9: dnsscience.v1.DSRecord.algorithm:type_name -> dnsscience.v1.DNSSECAlgorithm
	3,  // 10: dnsscience.v1.DNSSECStatusRequest.include_public_key_mode:type_name -> dnsscience.v1.IncludeKeyMode
	0,  // 11: dnsscience.v1.DNSSECStatusResponse.algorithm:type_name -> dnsscience.v1.DNSSECAlgorithm
	5,  // 12: dnsscience.v1.DNSSECStatusResponse.keys:type_name -> dnsscience.v1.DNSSECKey
	28, // 13: dnsscience.v1.DNSSECStatusResponse.last_validation:type_name -> google.protobuf.Timestamp
	29, // 14: dnsscience.v1.DNSSECStatusResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	30, // 15: dnsscience.v1.SignZoneResponse.duration:type_name -> google.protobuf.Duration
	29, // 16: dnsscience.v1.SignZoneResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	1,  // 17: dnsscience.v1.RolloverRequest.key_type:type_name -> dnsscience.v1.KeyType
	0,  // 18: dnsscience.v1.RolloverRequest.new_algorithm:type_name -> dnsscience.v1.DNSSECAlgorithm
	1,  // 19: dnsscience.v1.RolloverResponse.key_type:type_name -> dnsscience.v1.KeyType
	5,  // 20: dnsscience.v1.RolloverResponse.old_key:type_name -> dnsscience.v1.DNSSECKey
	5,  // 21: dnsscience.v1.RolloverResponse.new_key:type_name -> dnsscience.v1.DNSSECKey
	27, // 22: dnsscience.v1.RolloverResponse.timeline:type_name -> dnsscience.v1.RolloverResponse.RolloverPhase
	29, // 23: dnsscience.v1.RolloverResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	1,  // 24: dnsscience.v1.GetDSRequest.key_type:type_name -> dnsscience.v1.KeyType
	6,  // 25: dnsscience.v1.GetDSResponse.ds_records:type_name -> dnsscience.v1.DSRecord
	29, // 26: dnsscience.v1.GetDSResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	1,  // 27: dnsscience.v1.GenerateKeyRequest.type:type_name -> dnsscience.v1.KeyType
	0,  // 28: dnsscience.v1.GenerateKeyRequest.algorithm:type_name -> dnsscience.v1.DNSSECAlgorithm
	5,  // 29: dnsscience.v1.GenerateKeyResponse.key:type_name -> dnsscience.v1.DNSSECKey
	6,  // 30: dnsscience.v1.GenerateKeyResponse.ds_records:type_name -> dnsscience.v1.DSRecord
	29, // 31: dnsscience.v1.GenerateKeyResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	1,  // 32: dnsscience.v1.ImportKeyRequest.type:type_name -> dnsscience.v1.KeyType
	0,  // 33: dnsscience.v1.ImportKeyRequest.algorithm:type_name -> dnsscience.v1.DNSSECAlgorithm
	5,  // 34: dnsscience.v1.ImportKeyResponse.key:type_name -> dnsscience.v1.DNSSECKey
	29, // 35: dnsscience.v1.ImportKeyResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	5,  // 36: dnsscience.v1.ExportKeyResponse.key:type_name -> dnsscience.v1.DNSSECKey
	29, // 37: dnsscience.v1.ExportKeyResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	29, // 38: dnsscience.v1.DeleteKeyResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	29, // 39: dnsscience.v1.ValidateChainResponse.meta:type_name -> dnsscience.v1.ResponseMeta
	3,  // 40: dnsscience.v1.WatchKeysRequest.include_public_key_mode:type_name -> dnsscience.v1.IncludeKeyMode
	4,  // 41: dnsscience.v1.DNSSECEvent.type:type_name -> dnsscience.v1.DNSSECEvent.EventType
	28, // 42: dnsscience.v1.DNSSECEvent.timestamp:type_name -> google.protobuf.Timestamp
	5,  // 43: dnsscience.v1.DNSSECEvent.key:type_name -> dnsscience.v1.DNSSECKey
	28, // 44: dnsscience.v1.RolloverResponse.RolloverPhase.scheduled_date:type_name -> google.protobuf.Timestamp
	28, // 45: dnsscience.v1.RolloverResponse.RolloverPhase.completed_date:type_name -> google.protobuf.Timestamp
	7,  // 46: dnsscience.v1.DNSSECService.GetStatus:input_type -> dnsscience.v1.DNSSECStatusRequest
	9,  // 47: dnsscience.v1.DNSSECService.Sign:input_type -> dnsscience.v1.SignZoneRequest
	11, // 48: dnsscience.v1.DNSSECService.Rollover:input_type -> dnsscience.v1.RolloverRequest
	13, // 49: dnsscience.v1.DNSSECService.GetDS:input_type -> dnsscience.v1.GetDSRequest
	15, // 50: dnsscience.v1.DNSSECService.GenerateKey:input_type -> dnsscience.v1.GenerateKeyRequest
	17, // 51: dnsscience.v1.DNSSECService.ImportKey:input_type -> dnsscience.v1.ImportKeyRequest
	19, // 52: dnsscience.v1.DNSSECService.ExportKey:input_type -> dnsscience.v1.ExportKeyRequest
	21, // 53: dnsscience.v1.DNSSECService.DeleteKey:input_type -> dnsscience.v1.DeleteKeyRequest
	23, // 54: dnsscience.v1.DNSSECService.ValidateChain:input_type -> dnsscience.v1.ValidateChainRequest
	25, // 55: dnsscience.v1.DNSSECService.WatchKeys:input_type -> dnsscience.v1.WatchKeysRequest
	8,  // 56: dnsscience.v1.DNSSECService.GetStatus:output_type -> dnsscience.v1.DNSSECStatusResponse
	10, // 57: dnsscience.v1.DNSSECService.Sign:output_type -> dnsscience.v1.SignZoneResponse
	12, // 58: dnsscience.v1.DNSSECService.Rollover:output_type -> dnsscience.v1.RolloverResponse
	14, // 59: dnsscience.v1.DNSSECService.GetDS:output_type -> dnsscience.v1.GetDSResponse
	16, // 60: dnsscience.v1.DNSSECService.GenerateKey:output_type -> dnsscience.v1.GenerateKeyResponse
	18, // 61: dnsscience.v1.DNSSECService.ImportKey:output_type -> dnsscience.v1.ImportKeyResponse
	20, // 62: dnsscience.v1.DNSSECService.ExportKey:output_type -> dnsscience.v1.ExportKeyResponse
	22, // 63: dnsscience.v1.DNSSECService.DeleteKey:output_type -> dnsscience.v1.DeleteKeyResponse
	24, // 64: dnsscience.v1.DNSSECService.ValidateChain:output_type -> dnsscience.v1.ValidateChainResponse
	26, // 65: dnsscience.v1.DNSSECService.WatchKeys:output_type -> dnsscience.v1.DNSSECEvent
	56, // [56:66] is the sub-list for method output_type
	46, // [46:56] is the sub-list for method input_type
	46, // [46:46] is the sub-list for extension type_name
	46, // [46:46] is the sub-list for extension extendee
	0,  // [0:46] is the sub-list for field type_name
}

func init() { file_dnssec_proto_init() }
func file_dnssec_proto_init() {
	if File_dnssec_proto != nil {
		return
	}
	file_common_proto_init()
	file_dnssec_proto_msgTypes[21].OneofWrappers = []any{
		(*DNSSECEvent_Key)(nil),
		(*DNSSECEvent_ErrorMessage)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_dnssec_proto_rawDesc), len(file_dnssec_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   23,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_dnssec_proto_goTypes,
		DependencyIndexes: file_dnssec_proto_depIdxs,
		EnumInfos:         file_dnssec_proto_enumTypes,
		MessageInfos:      file_dnssec_proto_msgTypes,
	}.Build()
	File_dnssec_proto = out.File
	file_dnssec_proto_goTypes = nil
	file_dnssec_proto_depIdxs = nil
}
